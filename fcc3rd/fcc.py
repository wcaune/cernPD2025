# -*- coding: utf-8 -*-
"""Copy of tutorial_FCC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uoXuLHW9PnF_kgmbTKOGi0xX22bjpb_m

# FCC Example from A. Formenti, LBNL
Beam parameters from A. Ciarma, INFN
"""

#!pip install gdown
import gdown
file_id = "1b-vPCNpcoo53x2f7MrN9b5N90Bu3MrPE"
output_file = "FCC.tar.gz"
gdown.download(f"https://drive.google.com/uc?id={file_id}", output_file)
!tar -xzf FCC.tar.gz

"""# Visualizing the beams with Guinea-Pig"""

import os, sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import c, micro, nano, pi, milli

"""## Collider parameters"""

sigmaz = 15.6*milli
sigmax = 8775*nano
sigmay = 36.5*nano
npart = 6.16e11
n0 = npart / (sigmax * sigmay * sigmaz * (2.*pi)**(3./2.))

#Compare with parameters in acc.dat
#!cat gp/acc.dat

"""## Simulation parameters"""

# time
n_iterations = 256
iterations = range(n_iterations)
# box
nx = 256
ny = 256
nz = 256
Lx = 150*sigmax
Ly = 100*sigmay
Lz = 16*sigmaz
gridx = np.linspace(-0.5*Lx, 0.5*Lx, nx+1)
gridy = np.linspace(-0.5*Ly, 0.5*Ly, ny+1)
gridz = np.linspace(-0.5*Lz, 0.5*Lz, nz+1)
dx = gridx[1]-gridx[0]
dy = gridy[1]-gridy[0]
dz = gridz[1]-gridz[0]
nmacropart = 1e5
w0 = npart / nmacropart # weight

"""### Function to plot a single Guinea-Pig step"""

def one_step_gp(n, gp_dir):
    """
    inputs
        n: current timestep
        gp_dir: simulation folder
    outputs
        H_zx, H_zy: density of the beams integrated along y and x, resp
    """
    global w0, dx, dy, dz, gridx, gridy, gridz

    # get beams' data, columns are:
    # Particle Energy [GeV] | x [um] | y [um] | z [um] | x' [urad] | y' [urad]
    data1 = np.loadtxt(os.path.join(gp_dir, 'b1.%d' % n))
    data2 = np.loadtxt(os.path.join(gp_dir, 'b2.%d' % n))

    # get the number of macroparticles in the beams
    N1 = np.shape(data1)[0]
    N2 = np.shape(data2)[0]

    # stack the data together and convert to SI
    x_data = np.hstack((data1[:,1], data2[:,1]))*micro
    y_data = np.hstack((data1[:,2], data2[:,2]))*micro
    z_data = np.hstack((data1[:,3], data2[:,3]))*micro

    weights = np.ones(N1+N2) * w0
    weights[-N2:] = - w0 # assign negative weights to the second beam

    H_zx, bx, bz = np.histogram2d(x_data, z_data, bins=(gridx, gridz), weights=weights)
    H_zy, by, bz = np.histogram2d(y_data, z_data, bins=(gridy, gridz), weights=weights)

    return H_zx/(dz*dx), H_zy/(dz*dy)

# Plot a step as an example

step_number = 128
H_zx, H_zy = one_step_gp(step_number, "gp")

extent_zx = [gridz[0]/milli, gridz[-1]/milli, gridx[0]/micro, gridx[-1]/micro]
extent_zy = [gridz[0]/milli, gridz[-1]/milli, gridy[0]/micro, gridy[-1]/micro]

fig, ax = plt.subplots(ncols=2, nrows=1)
ax[0].imshow(H_zx, extent=extent_zx, cmap='seismic')
ax[0].set_aspect('auto')
ax[0].set_xlabel(r'z [$\mu$m]')
ax[0].set_ylabel(r'x [nm]')
ax[0].set_title(r'X-Z Plane')

ax[1].imshow(H_zy, extent=extent_zy, cmap='seismic')
ax[1].set_aspect('auto')
ax[1].set_xlabel(r'z [$\mu$m]')
ax[1].set_ylabel(r'y [nm]')
ax[1].set_title(r'Y-Z Plane')

"""## Generate a video of the colliding beams"""

#!mkdir -p "plots"

gp_dir = "gp"

v0 = n0 * np.sqrt(sigmax * sigmay) * 0.2
extent_zx = [gridz[0]/milli, gridz[-1]/milli, gridx[0]/micro, gridx[-1]/micro]
extent_zy = [gridz[0]/milli, gridz[-1]/milli, gridy[0]/micro, gridy[-1]/micro]

plt.rcParams.update({'font.size': 16})

# loop through the timesteps
for n in iterations:

    # prepare canvas
    fig, ax = plt.subplots(ncols=2, nrows=1, figsize=(8,4), dpi=300)

    H_zx, H_zy = one_step_gp(n, gp_dir)
    im=ax[0].imshow(H_zx, extent=extent_zx, cmap='seismic', origin='lower', interpolation='nearest', vmin=-v0, vmax=v0)
    im=ax[1].imshow(H_zy, extent=extent_zy, cmap='seismic', origin='lower', interpolation='nearest', vmin=-v0, vmax=v0)

    fig.subplots_adjust(right=0.85)
    cbar_ax = fig.add_axes([0.88, 0.085, 0.015, 0.87])
    fig.colorbar(im, cax=cbar_ax, label='density [arb. units]')

    for a in ax.reshape(-1):
        a.set_aspect('auto')
        a.set_xlabel(r'z [$\mu$m]')

    ax[0].set_ylabel(r'x [nm]')
    ax[1].set_ylabel(r'y [nm]')

    plt.savefig(f"plots/img_fcc_{n:04d}",dpi=300, bbox_inches='tight')
    plt.close("all")

! ffmpeg -framerate 30 -i 'plots/img_fcc_%04d.png' -y video_fcc.mp4

from IPython.display import HTML
import base64

video_path = 'video_fcc.mp4'
video_file = open(video_path, 'rb').read()
video_url = f"data:video/mp4;base64,{base64.b64encode(video_file).decode()}"
HTML(f'<video width=600 controls><source src="{video_url}" type="video/mp4"></video>')

